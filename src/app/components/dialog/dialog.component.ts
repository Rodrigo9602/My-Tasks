import { Component, Inject, OnInit } from '@angular/core';
import { MatDialogModule } from '@angular/material/dialog';
import { MAT_DIALOG_DATA, MatDialogRef } from '@angular/material/dialog';
import { MatSelectModule } from '@angular/material/select';
import { CommonModule, DatePipe } from '@angular/common';
import { FormsModule } from '@angular/forms';
import { FontAwesomeModule } from '@fortawesome/angular-fontawesome';


import { Task } from '../../models/task.model';
import { TaskInterface } from '../../interfaces/task.interface';

import { faUser, faFileLines, faFileText, faCalendarTimes, faCalendar, faEye, faEyeSlash } from '@fortawesome/free-regular-svg-icons';
import { faLock } from '@fortawesome/free-solid-svg-icons';
import { Toast } from '../../global/toast.global';






@Component({
  selector: 'app-dialog',
  standalone: true,
  imports: [CommonModule, MatDialogModule, FormsModule, MatSelectModule, FontAwesomeModule],
  providers: [DatePipe],
  templateUrl: './dialog.component.html',
  styleUrl: './dialog.component.scss'
})
export class DialogComponent implements OnInit {
  public task: TaskInterface;
  public taskUpdate: Task;
  public updateTaskData: boolean = false;
  private DateChanged: boolean = false;
  public date: any;
  public minDate: string = '';
  public states: Array<string> = ['creado', 'en progreso', 'terminado', 'no completado'];
  public showPassword: boolean = false;


  public nameIcon = faUser;
  public taskIcon = faFileLines;
  public descIcon = faFileText;
  public calendarIcon = faCalendar;
  public dateIcon = faCalendarTimes;
  public passIcon = faLock;
  public showIcon = faEye;

  constructor(
    public datePipe: DatePipe,
    public dialogRef: MatDialogRef<DialogComponent>,
    @Inject(MAT_DIALOG_DATA) public data: any,
  ) {
    this.task = {
      name: '',
      description: '',
      endingDate: new Date(),
    };

    this.taskUpdate = {
      _id: '',
      name: '',
      description: '',
      creationDate: new Date(),
      endingDate: new Date(),
      lastChange: new Date(),
      state: ''
    };


    const today = new Date();
    this.minDate = today.toISOString().split('T')[0];

  }

  /**
   * @method OnInit: 
   * An initial check is made of the type of form to be rendered,
   * in case the form to be rendered is the task update form (updForm),
   * the status of the task to be updated is checked,
   * if it is created a form is rendered with the possibility of modifying all the parameters of the task,
   * if it is in progress only updating the status will be allowed
   
   * @returns void  
   */

  ngOnInit(): void {

    if (this.data.form === 'updTask' && this.data.dataObject.task.state === 'creado') {
      this.updateTaskData = true;
      this.taskUpdate = JSON.parse(JSON.stringify(this.data.dataObject.task));
      this.formatDate();
    }
  }

  /**
   * @method formatDate: 
   * This method uses the datePipe to transform the endingDate shown in the forms,
   * in addition to adjusting the offset generated by default when creating Date type objects.
   
   * @returns void   
   */



  formatDate() {
    const date = new Date(this.data.dataObject.task.endingDate);
    const localDate = new Date(date.getTime() + date.getTimezoneOffset() * 60 * 1000);
    this.date = this.datePipe.transform(localDate, 'dd/MM/yyyy');
  }

  /**
   * @method onDateChange: 
   * This method is activated when detecting a change in the input of type date
   * and is used to create an object of type Date from the input received
   
   * @param {any} event: is a string formated date
   * @returns void
  
   */

  onDateChange(event: any) {
    this.DateChanged = true;
    this.taskUpdate.endingDate = new Date(event);
  }

  /**
   * @method onSubmit: 
   * This method determines the output of the component based on the type of form rendered.
   * First, a validation of the entered date is carried out using the validateDate() method,
   * then it is determined what type of form was rendered,
   * in the first case considered (add task or adddForm) the value of the received date is assigned to the public variable task,
   * since this will be displayed in ISO string format,
   * it is subsequently assigned to the object received at the initialization of the component,
   * which in turn constitutes the variable emitted as a response by it; In the second case (update task or updForm),
   * the initial state of the task to be updated is determined,
   * in order to know exactly which fields of the model could have been modified.
   * If the date is modified, an offset adjustment is made,
   * then, a Date type object is created taking into account the offset adjustment according to the time zone and finally it is converted to ISOString;
   * If the initial state was not created, only its state will be modified.

   * @returns void
   */


  onSubmit() {


    switch (this.data.form) {
      case 'addTask':

        if (!this.validateDate()) {
          Toast.fire({
            icon: 'error',
            title: 'Invalid ending date'
          });
          this.onCancel();
        } else {
          this.task.endingDate = this.date;
          this.data.dataObject = this.task;
          this.dialogRef.close(this.data.dataObject);
        }

        break;

      case 'updTask':
        if (this.data.dataObject.task.state === 'creado') {
          if (!this.DateChanged) {
            const utcDate = new Date(Date.UTC(
              this.date.split('/')[2],
              this.date.split('/')[1] - 1,
              this.date.split('/')[0]
            ));
            const offset = new Date().getTimezoneOffset();
            const date = new Date(utcDate.getTime() + offset * 60 * 1000);
            this.taskUpdate.endingDate = date;
          }
          this.data.dataObject.task = this.taskUpdate;
          this.data.dataObject.task.endingDate = this.taskUpdate.endingDate.toISOString();
          this.dialogRef.close(this.data.dataObject);
        } else {
          this.data.dataObject.task.state = this.taskUpdate.state;
          this.dialogRef.close(this.data.dataObject);
        }
        break;


    }

  }

  /**
   * @method validateDate: 
   * This method validates that the value entered in the date input is a valid date and equal to or later than the current date
   
   * @returns boolean
   */


  validateDate(): boolean {
    const DATE = new Date(this.date);
    DATE.setDate(DATE.getDate() + 1); // offset calibration
    const NOW = new Date();
    return DATE >= NOW;
  }

  /**
  * @method onCacel: 
  * This method close the dialog component returning undefined
  
  * @returns void
  */

  onCancel() {
    this.dialogRef.close();
  }
}
